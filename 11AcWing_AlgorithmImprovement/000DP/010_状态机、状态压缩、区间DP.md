## 状态机模型

### #1049. 大盗阿福

**描述**

<img src="C:%5CUsers%5Clyn95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220915232201065.png" alt="image-20220915232201065" style="zoom:67%;" />

  

**分析**

```markdown
选择出不拿相邻店铺时可以获得最大收益的选法
用转态划分，0->0,0->1,1->0;
```



![image-20220915234015953](https://gitee.com/lynbz1018/image/raw/master/img/20220915234017.png)

<img src="C:%5CUsers%5Clyn95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220915234637284.png" alt="image-20220915234637284" style="zoom:50%;" />



**Code**

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n;
int w[N];
int f[N][2];

void solve()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    
    for (int i = 1; i <= n; i ++ )
    {
        f[i][0] = max(f[i - 1][0], f[i - 1][1]);  // f[0][0] f[0][1] 都初始化为0
        f[i][1] = f[i - 1][0] + w[i];
    }
    
    printf("%d\n", max(f[n][0], f[n][1]));
}

int main()
{
    int T = 0;
    cin >> T;
    while (T -- )
        solve();
    
    return 0;
}
```



### #1057.股票买卖IV

**描述**

<img src="C:%5CUsers%5Clyn95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220917113917616.png" alt="image-20220917113917616" style="zoom:67%;" />

<img src="https://gitee.com/lynbz1018/image/raw/master/img/20220917113952.png" alt="image-20220917113951383" style="zoom:67%;" />

  

**分析**

![image-20220917122229868](https://gitee.com/lynbz1018/image/raw/master/img/20220917122231.png)



<img src="C:%5CUsers%5Clyn95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220917123057759.png" alt="image-20220917123057759" style="zoom:67%;" />

**Code**

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 110, INF = 0x3f3f3f3f;

int n, m;
int w[N];
int f[N][M][2];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    
    memset(f, -0x3f, sizeof f);
    for (int i = 0; i <= n; i ++ ) f[i][0][0] = 0;  // 没有进行买入时为0
    
    for (int i = 1; i  <= n; i ++ )
    {
        for (int j = 1; j <= m; j ++ )
        {
            f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]);
            f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]);
        }
    }
    
    int res = 0;
    for (int i = 0; i <= m; i ++ ) res = max(res, f[n][i][0]);
    
    printf("%d\n", res);
    
    return 0;
}
```



### #1058.股票买卖V

**描述**

<img src="C:%5CUsers%5Clyn95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220917130028863.png" alt="image-20220917130028863" style="zoom:67%;" />

**增加一个一天的冷冻期**

<img src="C:%5CUsers%5Clyn95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220917130122131.png" alt="image-20220917130122131" style="zoom:67%;" />

**分析**

`入口f[0][2] = 0  其他 都初始化为-INF`

<img src="C:%5CUsers%5Clyn95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220917132053247.png" alt="image-20220917132053247" style="zoom:67%;" />

  

**Code**

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, INF = 0x3f3f3f3f;

int n;
int w[N];
int f[N][3];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    
    f[0][0] = f[0][1] = -INF;
    f[0][2] = 0;
    
    for (int i = 1; i <= n; i ++ )
    {
        f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i]);
        f[i][1] = f[i - 1][0] + w[i];
        f[i][2] = max(f[i - 1][1], f[i - 1][2]);
    }
    
    printf("%d\n", max(f[n][1], f[n][2]));
    
    return 0;
}
```



### #1052.设计密码

**描述**

<img src="C:%5CUsers%5Clyn95%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220917134221514.png" alt="image-20220917134221514" style="zoom:67%;" />

   

**分析**

![image-20220917145237815](https://gitee.com/lynbz1018/image/raw/master/img/20220917145239.png)

   

**Code**

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 55, MOD = 1e9 + 7;

int n, m;
char str[N];
int f[N][N];

int main()
{
    cin >> n >> str + 1;
    m =strlen(str + 1);
    
    int ne[N] = {0};
    for (int i = 2, j = 0; i <= n; i ++ )
    {
        while (j && str[i] != str[j + 1]) j = ne[j];
        if (str[i] == str[j + 1]) j ++ ;
        ne[i] = j;
    }
    
    f[0][0] = 1;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            for (char k = 'a'; k <= 'z'; k ++ )
            {
                int u = j;
                while (u && k != str[u + 1]) u = ne[u];
                if (k == str[u + 1]) u ++ ;
                if (u < m) f[i + 1][u] = (f[i + 1][u] + f[i][j]) % MOD;
            }
            
    int res = 0;
    for (int i = 0; i < m; i ++ ) res = (res + f[n][i]) % MOD;
    
    cout << res << endl;
    
    return 0;
}
```



### #

**描述**







**分析**







**Code**

```c++

```



### #

**描述**







**分析**







**Code**

```c++

```