# 背包模型

## 前情回顾 

背包九讲  [GitHub](https://github.com/LYNBZ1018/algorithm/blob/master/AlgorithmNote/1000%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2.md)    [Gitee](https://gitee.com/lynbz1018/algorithm/blob/master/AlgorithmNote/1000%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2.md)



### #6 多重背包问题III

**描述**

```markdown
单调队列优化
```

**代码**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20010;

int n, m;
int f[N], g[N], q[N];

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
    {
        int v, w, s;
        cin >> v >> w >> s;
        memcpy(g, f, sizeof f);
        for (int j = 0; j < v; j ++ )
        {
            int hh = 0, tt = -1;
            for (int k = j; k <= m; k += v)
            {
                if (hh <= tt && q[hh] < k - s * v) hh ++ ;
                if (hh <= tt) f[k] = max(f[k], g[q[hh]] + (k - q[hh]) / v * w);
                while (hh <= tt && g[q[tt]] - (q[tt] - j) / v * w <= g[k] - (k - j) / v * w) tt -- ;
                q[++ tt ] = k;
            }
        }
    }
    
    cout << f[m] << endl;
    
    return 0;
}
```

​          

### #423 采药   01

**描述**

```markdown
孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。
我会给你一段时间，在这段时间里，你可以采到一些草药。
如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。
```

**分析**

```markdown
01 背包模型
```



**代码**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int f[N];

int main()
{
    scanf("%d%d", &m, &n);
    for (int i = 0; i < n; i ++ )
    {
        int v, w;
        scanf("%d%d", &v, &w);
        for (int j = m; j >= v; j -- )
            f[j] = max(f[j], f[j - v] + w);
    }
    
    printf("%d\n", f[m]);
    
    return 0;
}
```

​          

### #1024 装箱问题   01

**描述**

```markdown
有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积（正整数）。
要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。
```

**分析**

```markdown
体积就是权值，在不超过v的体积情况下权值之和最大。
最后让体积减去权值之和。
```

**代码**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20010;

int n, m;
int f[N];

int main()
{
    cin >> m >> n;
    for (int i = 0; i < n; i ++ )
    {
        int v;
        cin >> v;
        for (int j = m; j >= v; j -- )
            f[j] = max(f[j], f[j - v] + v);
    }
    
    cout << m - f[m];
    
    return 0;
}
```

​          

### #1022 宠物小精灵之收服   01 二维费用

**描述**

```markdown
当皮卡丘的体力小于等于0时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服。

我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。

如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。

小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。

现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。

请问，小智该如何选择收服哪些小精灵以达到他的目标呢？
```

**分析**

```markdown
每个小精灵只能被收服一次     01背包问题
每个小精灵被收服时 消耗精灵球 消耗皮卡丘体力    二维费用背包问题

花费1： 精灵球的数量
花费2： 皮卡丘体力值
价值：  小精灵的数量

皮卡丘的体力不能等于V2，所以应该从V2-1开始循环
```

![1.png](https://cdn.acwing.com/media/article/image/2022/04/30/186034_d0256ad9c8-1.png) 

**代码**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, M = 510;

int n, V1, V2;
int f[N][M];

int main()
{
    cin >> V1 >> V2 >> n;
    for (int i = 0; i < n; i ++ )
    {
        int v1, v2;
        cin >> v1 >> v2;
        for (int j = V1; j >= v1; j -- )
            for (int k = V2 - 1; k >= v2; k -- )
                f[j][k] = max(f[j][k], f[j - v1][k - v2] + 1);
    }
    
    cout << f[V1][V2 - 1] << ' ';
    int k = V2 - 1;
    while (k > 0 && f[V1][k - 1] == f[V1][V2 - 1]) k -- ;
    cout << V2 - k << endl;
    
    return 0;
}
```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```

​          

### #

**描述**

```markdown

```

**分析**



**代码**

```c++

```